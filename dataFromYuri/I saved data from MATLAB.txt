I saved data from MATLAB as raw binary, little-endian.

1) Vector file x_f64.bin
Layout:

uint64 n

double x[n]

C++ read:

std::ifstream in("x_f64.bin", std::ios::binary);
uint64_t n; in.read((char*)&n, 8);
std::vector<double> x(n);
in.read((char*)x.data(), 8*n);


2) Sparse matrix file L_csc.bin (CSC format, 0-based indices)
Layout:

uint64 m, uint64 n, uint64 nnz

uint64 colptr[n+1] // pointers into rowind/values

uint32 rowind[nnz] // row indices (0..m-1)

double values[nnz]

Meaning: entries of column j are k = colptr[j] ... colptr[j+1]-1 with (row=rowind[k], col=j, val=values[k]).

C++ read:

std::ifstream in("L_csc.bin", std::ios::binary);
uint64_t m,n,nnz;
in.read((char*)&m,8); in.read((char*)&n,8); in.read((char*)&nnz,8);

std::vector<uint64_t> colptr(n+1);
std::vector<uint32_t> rowind(nnz);
std::vector<double>   val(nnz);

in.read((char*)colptr.data(), 8*(n+1));
in.read((char*)rowind.data(), 4*nnz);
in.read((char*)val.data(),    8*nnz);


If you need CSR instead of CSC, you can convert after reading.

---------------------------------------------------
(2) dx?  Is that the distance between grid points?  I have that as 1.  Does it matter?

I belive it will matter a lot, so I have 1 the total domain length in each direction

and yes Yuris asked me to use my 2D version program first as it is easier to get data from there, just with increased amounts of points

5 diagonal Laplacian, 2000^2 in each matrix dimension

Sorry, it took me some time to rework 2D program to be able to work with a big matricies

now dx = 5.0E-4

I now you do not need L, still I am leaving it also
---------------------------------------------------------

In your case RHS is 
RHS_p +2BT*RHS_f
so both parts of the vector are used in the assembly of rhs
then Schure matrix is
(L+2BT*B)
so effectivly you are trying to solve for
(L+2BT*B)^-1(RHS_p +2BT*RHS_f)

but what your proposed is not to use this system as it is but precondition it
so
you build
RHS_new = L^-1(RHS_p +2BT*RHS_f)

then solve
(I+2L^-1BT*B)^-1RHS_new

you do not need to explicitly build L^-1BT*B
basicaly in BiCGstab2 youy just need to provide the multiplication of (I+2L^-1BT*B) by vector
for this you will need your L^-1 solver. basicaly RHS_new +  L^-1(BT(B*RHS_new)))

I hope this explanation helps
