! wrapffortranbindings.f
! This file is generated by Shroud 0.14.0. Do not edit.
!>
!! \file wrapffortranbindings.f
!! \brief Shroud generated wrapper for FortranBindings library
!<
! splicer begin file_top
! splicer end file_top
module fortranbindings_mod
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    interface

        subroutine c_init_immersed_eq_d_i32(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_d_i32")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_DOUBLE), intent(IN) :: p(*)
            real(C_DOUBLE), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_d_i32

        subroutine c_init_immersed_eq_s_i32(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_s_i32")
            use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_FLOAT), intent(IN) :: p(*)
            real(C_FLOAT), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_s_i32

        subroutine c_init_immersed_eq_d_i64(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_d_i64")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_DOUBLE), intent(IN) :: p(*)
            real(C_DOUBLE), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_d_i64

        subroutine c_init_immersed_eq_s_i64(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_s_i64")
            use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_FLOAT), intent(IN) :: p(*)
            real(C_FLOAT), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_s_i64

        subroutine c_solve_immersed_eq_d_i32(result, nnzB, rowPointersB, &
                colOffsetsB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_d_i32")
            use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT32_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowPointersB(*)
            integer(C_INT32_T), intent(IN) :: colOffsetsB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_d_i32

        subroutine c_solve_immersed_eq_s_i32(result, nnzB, rowPointersB, &
                colOffsetsB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_s_i32")
            use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT32_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowPointersB(*)
            integer(C_INT32_T), intent(IN) :: colOffsetsB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_s_i32

        subroutine c_solve_immersed_eq_d_i64(result, nnzB, rowPointersB, &
                colOffsetsB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_d_i64")
            use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT64_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowPointersB(*)
            integer(C_INT64_T), intent(IN) :: colOffsetsB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_d_i64

        subroutine c_solve_immersed_eq_s_i64(result, nnzB, rowPointersB, &
                colOffsetsB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_s_i64")
            use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT64_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowPointersB(*)
            integer(C_INT64_T), intent(IN) :: colOffsetsB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_s_i64
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

    subroutine init_immersed_eq_d_i32(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_DOUBLE), intent(IN) :: p(:)
        real(C_DOUBLE), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_d_i32
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_d_i32(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_d_i32
    end subroutine init_immersed_eq_d_i32

    subroutine init_immersed_eq_s_i32(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_FLOAT), intent(IN) :: p(:)
        real(C_FLOAT), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_s_i32
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_s_i32(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_s_i32
    end subroutine init_immersed_eq_s_i32

    subroutine init_immersed_eq_d_i64(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_DOUBLE), intent(IN) :: p(:)
        real(C_DOUBLE), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_d_i64
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_d_i64(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_d_i64
    end subroutine init_immersed_eq_d_i64

    subroutine init_immersed_eq_s_i64(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_FLOAT), intent(IN) :: p(:)
        real(C_FLOAT), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_s_i64
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_s_i64(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_s_i64
    end subroutine init_immersed_eq_s_i64

    subroutine solve_immersed_eq_d_i32(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT32_T, C_SIZE_T
        real(C_DOUBLE), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT32_T), intent(IN) :: rowPointersB(:)
        integer(C_INT32_T), intent(IN) :: colOffsetsB(:)
        real(C_DOUBLE), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_d_i32
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_d_i32(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_d_i32
    end subroutine solve_immersed_eq_d_i32

    subroutine solve_immersed_eq_s_i32(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT32_T, C_SIZE_T
        real(C_FLOAT), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT32_T), intent(IN) :: rowPointersB(:)
        integer(C_INT32_T), intent(IN) :: colOffsetsB(:)
        real(C_FLOAT), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_s_i32
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_s_i32(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_s_i32
    end subroutine solve_immersed_eq_s_i32

    subroutine solve_immersed_eq_d_i64(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT64_T, C_SIZE_T
        real(C_DOUBLE), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT64_T), intent(IN) :: rowPointersB(:)
        integer(C_INT64_T), intent(IN) :: colOffsetsB(:)
        real(C_DOUBLE), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_d_i64
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_d_i64(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_d_i64
    end subroutine solve_immersed_eq_d_i64

    subroutine solve_immersed_eq_s_i64(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT64_T, C_SIZE_T
        real(C_FLOAT), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT64_T), intent(IN) :: rowPointersB(:)
        integer(C_INT64_T), intent(IN) :: colOffsetsB(:)
        real(C_FLOAT), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_s_i64
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_s_i64(result, nnzB, rowPointersB, &
            colOffsetsB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_s_i64
    end subroutine solve_immersed_eq_s_i64

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module fortranbindings_mod
