! wrapffortranbindings.f
! This file is generated by Shroud 0.14.0. Do not edit.
!>
!! \file wrapffortranbindings.f
!! \brief Shroud generated wrapper for FortranBindings library
!<
! splicer begin file_top
! splicer end file_top
module fortranbindings_mod
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    interface

        subroutine c_init_immersed_eq_d_i32(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                dt, tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_d_i32")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_DOUBLE), intent(IN) :: p(*)
            real(C_DOUBLE), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: dt
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_d_i32

        subroutine c_init_immersed_eq_s_i32(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                dt, tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_s_i32")
            use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_FLOAT), intent(IN) :: p(*)
            real(C_FLOAT), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: dt
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_s_i32

        subroutine c_init_immersed_eq_d_i64(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                dt, tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_d_i64")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_DOUBLE), intent(IN) :: p(*)
            real(C_DOUBLE), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: dt
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_d_i64

        subroutine c_init_immersed_eq_s_i64(gridHeight, gridWidth, &
                gridDepth, fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, &
                dt, tolerance, maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_s_i64")
            use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: gridHeight
            integer(C_SIZE_T), value, intent(IN) :: gridWidth
            integer(C_SIZE_T), value, intent(IN) :: gridDepth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_FLOAT), intent(IN) :: p(*)
            real(C_FLOAT), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: dt
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_s_i64

        subroutine solve_immersed_eq_d_i32(result, nnzB, rowOffsetsB, &
                colIndsB, valuesB) &
                bind(C, name="FOR_solveImmersedEq_d_i32")
            use iso_c_binding, only : C_DOUBLE, C_INT32_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT32_T), intent(IN) :: colIndsB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
        end subroutine solve_immersed_eq_d_i32

        subroutine solve_immersed_eq_s_i32(result, nnzB, rowOffsetsB, &
                colIndsB, valuesB) &
                bind(C, name="FOR_solveImmersedEq_s_i32")
            use iso_c_binding, only : C_FLOAT, C_INT32_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT32_T), intent(IN) :: colIndsB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
        end subroutine solve_immersed_eq_s_i32

        subroutine solve_immersed_eq_d_i64(result, nnzB, rowOffsetsB, &
                colIndsB, valuesB) &
                bind(C, name="FOR_solveImmersedEq_d_i64")
            use iso_c_binding, only : C_DOUBLE, C_INT64_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT64_T), intent(IN) :: colIndsB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
        end subroutine solve_immersed_eq_d_i64

        subroutine solve_immersed_eq_s_i64(result, nnzB, rowOffsetsB, &
                colIndsB, valuesB) &
                bind(C, name="FOR_solveImmersedEq_s_i64")
            use iso_c_binding, only : C_FLOAT, C_INT64_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT64_T), intent(IN) :: colIndsB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
        end subroutine solve_immersed_eq_s_i64

        subroutine solve_immersed_eq_primes_d_i32(resultPPrime, &
                resultFPrime, nnzB, rowOffsetsB, colIndsB, valuesB, &
                nnzR, colOffsetsR, rowIndsR, valuesR, UGamma, uStar) &
                bind(C, name="FOR_solveImmersedEqPrimes_d_i32")
            use iso_c_binding, only : C_DOUBLE, C_INT32_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: resultPPrime(*)
            real(C_DOUBLE), intent(OUT) :: resultFPrime(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT32_T), intent(IN) :: colIndsB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzR
            integer(C_INT32_T), intent(IN) :: colOffsetsR(*)
            integer(C_INT32_T), intent(IN) :: rowIndsR(*)
            real(C_DOUBLE), intent(IN) :: valuesR(*)
            real(C_DOUBLE), intent(IN) :: UGamma(*)
            real(C_DOUBLE), intent(IN) :: uStar(*)
        end subroutine solve_immersed_eq_primes_d_i32

        subroutine solve_immersed_eq_primes_s_i32(resultPPrime, &
                resultFPrime, nnzB, rowOffsetsB, colIndsB, valuesB, &
                nnzR, colOffsetsR, rowIndsR, valuesR, UGamma, uStar) &
                bind(C, name="FOR_solveImmersedEqPrimes_s_i32")
            use iso_c_binding, only : C_FLOAT, C_INT32_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: resultPPrime(*)
            real(C_FLOAT), intent(OUT) :: resultFPrime(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT32_T), intent(IN) :: colIndsB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzR
            integer(C_INT32_T), intent(IN) :: colOffsetsR(*)
            integer(C_INT32_T), intent(IN) :: rowIndsR(*)
            real(C_FLOAT), intent(IN) :: valuesR(*)
            real(C_FLOAT), intent(IN) :: UGamma(*)
            real(C_FLOAT), intent(IN) :: uStar(*)
        end subroutine solve_immersed_eq_primes_s_i32

        subroutine solve_immersed_eq_primes_d_i64(resultPPrime, &
                resultFPrime, nnzB, rowOffsetsB, colIndsB, valuesB, &
                nnzR, colOffsetsR, rowIndsR, valuesR, UGamma, uStar) &
                bind(C, name="FOR_solveImmersedEqPrimes_d_i64")
            use iso_c_binding, only : C_DOUBLE, C_INT64_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: resultPPrime(*)
            real(C_DOUBLE), intent(OUT) :: resultFPrime(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT64_T), intent(IN) :: colIndsB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzR
            integer(C_INT64_T), intent(IN) :: colOffsetsR(*)
            integer(C_INT64_T), intent(IN) :: rowIndsR(*)
            real(C_DOUBLE), intent(IN) :: valuesR(*)
            real(C_DOUBLE), intent(IN) :: UGamma(*)
            real(C_DOUBLE), intent(IN) :: uStar(*)
        end subroutine solve_immersed_eq_primes_d_i64

        subroutine solve_immersed_eq_primes_s_i64(resultPPrime, &
                resultFPrime, nnzB, rowOffsetsB, colIndsB, valuesB, &
                nnzR, colOffsetsR, rowIndsR, valuesR, UGamma, uStar) &
                bind(C, name="FOR_solveImmersedEqPrimes_s_i64")
            use iso_c_binding, only : C_FLOAT, C_INT64_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: resultPPrime(*)
            real(C_FLOAT), intent(OUT) :: resultFPrime(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowOffsetsB(*)
            integer(C_INT64_T), intent(IN) :: colIndsB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzR
            integer(C_INT64_T), intent(IN) :: colOffsetsR(*)
            integer(C_INT64_T), intent(IN) :: rowIndsR(*)
            real(C_FLOAT), intent(IN) :: valuesR(*)
            real(C_FLOAT), intent(IN) :: UGamma(*)
            real(C_FLOAT), intent(IN) :: uStar(*)
        end subroutine solve_immersed_eq_primes_s_i64
    end interface

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

    subroutine init_immersed_eq_d_i32(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_DOUBLE), intent(IN) :: p(:)
        real(C_DOUBLE), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: dt
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_d_i32
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_d_i32(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, &
            tolerance, maxBCGIterations)
        ! splicer end function.init_immersed_eq_d_i32
    end subroutine init_immersed_eq_d_i32

    subroutine init_immersed_eq_s_i32(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_FLOAT), intent(IN) :: p(:)
        real(C_FLOAT), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: dt
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_s_i32
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_s_i32(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, &
            tolerance, maxBCGIterations)
        ! splicer end function.init_immersed_eq_s_i32
    end subroutine init_immersed_eq_s_i32

    subroutine init_immersed_eq_d_i64(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_DOUBLE), intent(IN) :: p(:)
        real(C_DOUBLE), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: dt
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_d_i64
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_d_i64(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, &
            tolerance, maxBCGIterations)
        ! splicer end function.init_immersed_eq_d_i64
    end subroutine init_immersed_eq_d_i64

    subroutine init_immersed_eq_s_i64(gridHeight, gridWidth, gridDepth, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance, &
            maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: gridHeight
        integer(C_SIZE_T), value, intent(IN) :: gridWidth
        integer(C_SIZE_T), value, intent(IN) :: gridDepth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_FLOAT), intent(IN) :: p(:)
        real(C_FLOAT), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: dt
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_s_i64
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_s_i64(gridHeight, gridWidth, gridDepth, &
            SH_fSize, nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, &
            tolerance, maxBCGIterations)
        ! splicer end function.init_immersed_eq_s_i64
    end subroutine init_immersed_eq_s_i64

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module fortranbindings_mod
