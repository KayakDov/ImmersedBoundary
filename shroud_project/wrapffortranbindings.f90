! wrapffortranbindings.f
! This file is generated by Shroud 0.14.0. Do not edit.
!>
!! \file wrapffortranbindings.f
!! \brief Shroud generated wrapper for FortranBindings library
!<
! splicer begin file_top
! splicer end file_top
module fortranbindings_mod
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    interface

        subroutine c_solve_bi_cgstab_float(A, aLd, inds, indsStride, &
                numInds, b, bStride, bSize, prealocatedSizeX7, &
                prealocatedLd, maxIterations, tolerance) &
                bind(C, name="FOR_solveBiCGSTAB_float")
            use iso_c_binding, only : C_FLOAT, C_INT32_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(INOUT) :: A
            integer(C_SIZE_T), value, intent(IN) :: aLd
            integer(C_INT32_T), intent(INOUT) :: inds
            integer(C_SIZE_T), value, intent(IN) :: indsStride
            integer(C_SIZE_T), value, intent(IN) :: numInds
            real(C_FLOAT), intent(INOUT) :: b
            integer(C_SIZE_T), value, intent(IN) :: bStride
            integer(C_SIZE_T), value, intent(IN) :: bSize
            real(C_FLOAT), intent(INOUT) :: prealocatedSizeX7
            integer(C_SIZE_T), value, intent(IN) :: prealocatedLd
            integer(C_SIZE_T), value, intent(IN) :: maxIterations
            real(C_FLOAT), value, intent(IN) :: tolerance
        end subroutine c_solve_bi_cgstab_float

        subroutine c_solve_bi_cgstab_double(A, aLd, inds, indsStride, &
                numInds, b, bStride, bSize, prealocatedSizeX7, &
                prealocatedLd, maxIterations, tolerance) &
                bind(C, name="FOR_solveBiCGSTAB_double")
            use iso_c_binding, only : C_DOUBLE, C_INT32_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(INOUT) :: A
            integer(C_SIZE_T), value, intent(IN) :: aLd
            integer(C_INT32_T), intent(INOUT) :: inds
            integer(C_SIZE_T), value, intent(IN) :: indsStride
            integer(C_SIZE_T), value, intent(IN) :: numInds
            real(C_DOUBLE), intent(INOUT) :: b
            integer(C_SIZE_T), value, intent(IN) :: bStride
            integer(C_SIZE_T), value, intent(IN) :: bSize
            real(C_DOUBLE), intent(INOUT) :: prealocatedSizeX7
            integer(C_SIZE_T), value, intent(IN) :: prealocatedLd
            integer(C_SIZE_T), value, intent(IN) :: maxIterations
            real(C_DOUBLE), value, intent(IN) :: tolerance
        end subroutine c_solve_bi_cgstab_double

        subroutine c_solve_decomp_float(frontBack, fbLd, leftRight, &
                lrLd, topBottom, tbLd, f, fStride, x, xStride, height, &
                width, depth, rowsXRows, rowsXRowsLd, colsXCols, &
                colsXColsLd, depthsXDepths, depthsXDepthsLd, maxDimX3, &
                maxDimX3Ld) &
                bind(C, name="FOR_solveDecomp_float")
            use iso_c_binding, only : C_FLOAT, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(INOUT) :: frontBack
            integer(C_SIZE_T), value, intent(IN) :: fbLd
            real(C_FLOAT), intent(INOUT) :: leftRight
            integer(C_SIZE_T), value, intent(IN) :: lrLd
            real(C_FLOAT), intent(INOUT) :: topBottom
            integer(C_SIZE_T), value, intent(IN) :: tbLd
            real(C_FLOAT), intent(INOUT) :: f
            integer(C_SIZE_T), value, intent(IN) :: fStride
            real(C_FLOAT), intent(INOUT) :: x
            integer(C_SIZE_T), value, intent(IN) :: xStride
            integer(C_SIZE_T), value, intent(IN) :: height
            integer(C_SIZE_T), value, intent(IN) :: width
            integer(C_SIZE_T), value, intent(IN) :: depth
            real(C_FLOAT), intent(INOUT) :: rowsXRows
            integer(C_SIZE_T), value, intent(IN) :: rowsXRowsLd
            real(C_FLOAT), intent(INOUT) :: colsXCols
            integer(C_SIZE_T), value, intent(IN) :: colsXColsLd
            real(C_FLOAT), intent(INOUT) :: depthsXDepths
            integer(C_SIZE_T), value, intent(IN) :: depthsXDepthsLd
            real(C_FLOAT), intent(INOUT) :: maxDimX3
            integer(C_SIZE_T), value, intent(IN) :: maxDimX3Ld
        end subroutine c_solve_decomp_float

        subroutine c_solve_decomp_double(frontBack, fbLd, leftRight, &
                lrLd, topBottom, tbLd, f, fStride, x, xStride, height, &
                width, depth, rowsXRows, rowsXRowsLd, colsXCols, &
                colsXColsLd, depthsXDepths, depthsXDepthsLd, maxDimX3, &
                maxDimX3Ld) &
                bind(C, name="FOR_solveDecomp_double")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(INOUT) :: frontBack
            integer(C_SIZE_T), value, intent(IN) :: fbLd
            real(C_DOUBLE), intent(INOUT) :: leftRight
            integer(C_SIZE_T), value, intent(IN) :: lrLd
            real(C_DOUBLE), intent(INOUT) :: topBottom
            integer(C_SIZE_T), value, intent(IN) :: tbLd
            real(C_DOUBLE), intent(INOUT) :: f
            integer(C_SIZE_T), value, intent(IN) :: fStride
            real(C_DOUBLE), intent(INOUT) :: x
            integer(C_SIZE_T), value, intent(IN) :: xStride
            integer(C_SIZE_T), value, intent(IN) :: height
            integer(C_SIZE_T), value, intent(IN) :: width
            integer(C_SIZE_T), value, intent(IN) :: depth
            real(C_DOUBLE), intent(INOUT) :: rowsXRows
            integer(C_SIZE_T), value, intent(IN) :: rowsXRowsLd
            real(C_DOUBLE), intent(INOUT) :: colsXCols
            integer(C_SIZE_T), value, intent(IN) :: colsXColsLd
            real(C_DOUBLE), intent(INOUT) :: depthsXDepths
            integer(C_SIZE_T), value, intent(IN) :: depthsXDepthsLd
            real(C_DOUBLE), intent(INOUT) :: maxDimX3
            integer(C_SIZE_T), value, intent(IN) :: maxDimX3Ld
        end subroutine c_solve_decomp_double
    end interface

    interface solve_bi_cgstab
        module procedure solve_bi_cgstab_float
        module procedure solve_bi_cgstab_double
    end interface solve_bi_cgstab

    interface solve_decomp
        module procedure solve_decomp_float
        module procedure solve_decomp_double
    end interface solve_decomp

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

    subroutine solve_bi_cgstab_float(A, aLd, inds, indsStride, numInds, &
            b, bStride, bSize, prealocatedSizeX7, prealocatedLd, &
            maxIterations, tolerance)
        use iso_c_binding, only : C_FLOAT, C_INT32_T, C_SIZE_T
        real(C_FLOAT), intent(INOUT) :: A
        integer(C_SIZE_T), value, intent(IN) :: aLd
        integer(C_INT32_T), intent(INOUT) :: inds
        integer(C_SIZE_T), value, intent(IN) :: indsStride
        integer(C_SIZE_T), value, intent(IN) :: numInds
        real(C_FLOAT), intent(INOUT) :: b
        integer(C_SIZE_T), value, intent(IN) :: bStride
        integer(C_SIZE_T), value, intent(IN) :: bSize
        real(C_FLOAT), intent(INOUT) :: prealocatedSizeX7
        integer(C_SIZE_T), value, intent(IN) :: prealocatedLd
        integer(C_SIZE_T), value, intent(IN) :: maxIterations
        real(C_FLOAT), value, intent(IN) :: tolerance
        ! splicer begin function.solve_bi_cgstab_float
        call c_solve_bi_cgstab_float(A, aLd, inds, indsStride, numInds, &
            b, bStride, bSize, prealocatedSizeX7, prealocatedLd, &
            maxIterations, tolerance)
        ! splicer end function.solve_bi_cgstab_float
    end subroutine solve_bi_cgstab_float

    subroutine solve_bi_cgstab_double(A, aLd, inds, indsStride, numInds, &
            b, bStride, bSize, prealocatedSizeX7, prealocatedLd, &
            maxIterations, tolerance)
        use iso_c_binding, only : C_DOUBLE, C_INT32_T, C_SIZE_T
        real(C_DOUBLE), intent(INOUT) :: A
        integer(C_SIZE_T), value, intent(IN) :: aLd
        integer(C_INT32_T), intent(INOUT) :: inds
        integer(C_SIZE_T), value, intent(IN) :: indsStride
        integer(C_SIZE_T), value, intent(IN) :: numInds
        real(C_DOUBLE), intent(INOUT) :: b
        integer(C_SIZE_T), value, intent(IN) :: bStride
        integer(C_SIZE_T), value, intent(IN) :: bSize
        real(C_DOUBLE), intent(INOUT) :: prealocatedSizeX7
        integer(C_SIZE_T), value, intent(IN) :: prealocatedLd
        integer(C_SIZE_T), value, intent(IN) :: maxIterations
        real(C_DOUBLE), value, intent(IN) :: tolerance
        ! splicer begin function.solve_bi_cgstab_double
        call c_solve_bi_cgstab_double(A, aLd, inds, indsStride, numInds, &
            b, bStride, bSize, prealocatedSizeX7, prealocatedLd, &
            maxIterations, tolerance)
        ! splicer end function.solve_bi_cgstab_double
    end subroutine solve_bi_cgstab_double

    subroutine solve_decomp_float(frontBack, fbLd, leftRight, lrLd, &
            topBottom, tbLd, f, fStride, x, xStride, height, width, &
            depth, rowsXRows, rowsXRowsLd, colsXCols, colsXColsLd, &
            depthsXDepths, depthsXDepthsLd, maxDimX3, maxDimX3Ld)
        use iso_c_binding, only : C_FLOAT, C_SIZE_T
        real(C_FLOAT), intent(INOUT) :: frontBack
        integer(C_SIZE_T), value, intent(IN) :: fbLd
        real(C_FLOAT), intent(INOUT) :: leftRight
        integer(C_SIZE_T), value, intent(IN) :: lrLd
        real(C_FLOAT), intent(INOUT) :: topBottom
        integer(C_SIZE_T), value, intent(IN) :: tbLd
        real(C_FLOAT), intent(INOUT) :: f
        integer(C_SIZE_T), value, intent(IN) :: fStride
        real(C_FLOAT), intent(INOUT) :: x
        integer(C_SIZE_T), value, intent(IN) :: xStride
        integer(C_SIZE_T), value, intent(IN) :: height
        integer(C_SIZE_T), value, intent(IN) :: width
        integer(C_SIZE_T), value, intent(IN) :: depth
        real(C_FLOAT), intent(INOUT) :: rowsXRows
        integer(C_SIZE_T), value, intent(IN) :: rowsXRowsLd
        real(C_FLOAT), intent(INOUT) :: colsXCols
        integer(C_SIZE_T), value, intent(IN) :: colsXColsLd
        real(C_FLOAT), intent(INOUT) :: depthsXDepths
        integer(C_SIZE_T), value, intent(IN) :: depthsXDepthsLd
        real(C_FLOAT), intent(INOUT) :: maxDimX3
        integer(C_SIZE_T), value, intent(IN) :: maxDimX3Ld
        ! splicer begin function.solve_decomp_float
        call c_solve_decomp_float(frontBack, fbLd, leftRight, lrLd, &
            topBottom, tbLd, f, fStride, x, xStride, height, width, &
            depth, rowsXRows, rowsXRowsLd, colsXCols, colsXColsLd, &
            depthsXDepths, depthsXDepthsLd, maxDimX3, maxDimX3Ld)
        ! splicer end function.solve_decomp_float
    end subroutine solve_decomp_float

    subroutine solve_decomp_double(frontBack, fbLd, leftRight, lrLd, &
            topBottom, tbLd, f, fStride, x, xStride, height, width, &
            depth, rowsXRows, rowsXRowsLd, colsXCols, colsXColsLd, &
            depthsXDepths, depthsXDepthsLd, maxDimX3, maxDimX3Ld)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        real(C_DOUBLE), intent(INOUT) :: frontBack
        integer(C_SIZE_T), value, intent(IN) :: fbLd
        real(C_DOUBLE), intent(INOUT) :: leftRight
        integer(C_SIZE_T), value, intent(IN) :: lrLd
        real(C_DOUBLE), intent(INOUT) :: topBottom
        integer(C_SIZE_T), value, intent(IN) :: tbLd
        real(C_DOUBLE), intent(INOUT) :: f
        integer(C_SIZE_T), value, intent(IN) :: fStride
        real(C_DOUBLE), intent(INOUT) :: x
        integer(C_SIZE_T), value, intent(IN) :: xStride
        integer(C_SIZE_T), value, intent(IN) :: height
        integer(C_SIZE_T), value, intent(IN) :: width
        integer(C_SIZE_T), value, intent(IN) :: depth
        real(C_DOUBLE), intent(INOUT) :: rowsXRows
        integer(C_SIZE_T), value, intent(IN) :: rowsXRowsLd
        real(C_DOUBLE), intent(INOUT) :: colsXCols
        integer(C_SIZE_T), value, intent(IN) :: colsXColsLd
        real(C_DOUBLE), intent(INOUT) :: depthsXDepths
        integer(C_SIZE_T), value, intent(IN) :: depthsXDepthsLd
        real(C_DOUBLE), intent(INOUT) :: maxDimX3
        integer(C_SIZE_T), value, intent(IN) :: maxDimX3Ld
        ! splicer begin function.solve_decomp_double
        call c_solve_decomp_double(frontBack, fbLd, leftRight, lrLd, &
            topBottom, tbLd, f, fStride, x, xStride, height, width, &
            depth, rowsXRows, rowsXRowsLd, colsXCols, colsXColsLd, &
            depthsXDepths, depthsXDepthsLd, maxDimX3, maxDimX3Ld)
        ! splicer end function.solve_decomp_double
    end subroutine solve_decomp_double

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module fortranbindings_mod
