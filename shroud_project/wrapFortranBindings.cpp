// wrapFortranBindings.cpp
// This file is generated by Shroud 0.14.0. Do not edit.

#include "FortranBindings.hpp"
#include "wrapFortranBindings.h"

// splicer begin CXX_definitions
// splicer end CXX_definitions

extern "C" {

// splicer begin C_definitions
// splicer end C_definitions

void FOR_initImmersedEq_d_i32(size_t gridHeight, size_t gridWidth,
    size_t gridDepth, size_t fSize, size_t nnzMaxB, double *p,
    double *f, double deltaX, double deltaY, double deltaZ, double dt,
    double tolerance, size_t maxBCGIterations)
{
    // splicer begin function.initImmersedEq_d_i32
    initImmersedEq_d_i32(gridHeight, gridWidth, gridDepth, fSize,
        nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance,
        maxBCGIterations);
    // splicer end function.initImmersedEq_d_i32
}

void FOR_initImmersedEq_s_i32(size_t gridHeight, size_t gridWidth,
    size_t gridDepth, size_t fSize, size_t nnzMaxB, float *p, float *f,
    double deltaX, double deltaY, double deltaZ, double dt,
    double tolerance, size_t maxBCGIterations)
{
    // splicer begin function.initImmersedEq_s_i32
    initImmersedEq_s_i32(gridHeight, gridWidth, gridDepth, fSize,
        nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance,
        maxBCGIterations);
    // splicer end function.initImmersedEq_s_i32
}

void FOR_initImmersedEq_d_i64(size_t gridHeight, size_t gridWidth,
    size_t gridDepth, size_t fSize, size_t nnzMaxB, double *p,
    double *f, double deltaX, double deltaY, double deltaZ, double dt,
    double tolerance, size_t maxBCGIterations)
{
    // splicer begin function.initImmersedEq_d_i64
    initImmersedEq_d_i64(gridHeight, gridWidth, gridDepth, fSize,
        nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance,
        maxBCGIterations);
    // splicer end function.initImmersedEq_d_i64
}

void FOR_initImmersedEq_s_i64(size_t gridHeight, size_t gridWidth,
    size_t gridDepth, size_t fSize, size_t nnzMaxB, float *p, float *f,
    double deltaX, double deltaY, double deltaZ, double dt,
    double tolerance, size_t maxBCGIterations)
{
    // splicer begin function.initImmersedEq_s_i64
    initImmersedEq_s_i64(gridHeight, gridWidth, gridDepth, fSize,
        nnzMaxB, p, f, deltaX, deltaY, deltaZ, dt, tolerance,
        maxBCGIterations);
    // splicer end function.initImmersedEq_s_i64
}

void FOR_solveImmersedEq_d_i32(double *result, size_t nnzB,
    int32_t *rowOffsetsB, int32_t *colIndsB, double *valuesB)
{
    // splicer begin function.solveImmersedEq_d_i32
    solveImmersedEq_d_i32(result, nnzB, rowOffsetsB, colIndsB, valuesB);
    // splicer end function.solveImmersedEq_d_i32
}

void FOR_solveImmersedEq_s_i32(float *result, size_t nnzB,
    int32_t *rowOffsetsB, int32_t *colIndsB, float *valuesB)
{
    // splicer begin function.solveImmersedEq_s_i32
    solveImmersedEq_s_i32(result, nnzB, rowOffsetsB, colIndsB, valuesB);
    // splicer end function.solveImmersedEq_s_i32
}

void FOR_solveImmersedEq_d_i64(double *result, size_t nnzB,
    int64_t *rowOffsetsB, int64_t *colIndsB, double *valuesB)
{
    // splicer begin function.solveImmersedEq_d_i64
    solveImmersedEq_d_i64(result, nnzB, rowOffsetsB, colIndsB, valuesB);
    // splicer end function.solveImmersedEq_d_i64
}

void FOR_solveImmersedEq_s_i64(float *result, size_t nnzB,
    int64_t *rowOffsetsB, int64_t *colIndsB, float *valuesB)
{
    // splicer begin function.solveImmersedEq_s_i64
    solveImmersedEq_s_i64(result, nnzB, rowOffsetsB, colIndsB, valuesB);
    // splicer end function.solveImmersedEq_s_i64
}

void FOR_solveImmersedEqPrimes_d_i32(double *resultPPrime,
    double *resultFPrime, size_t nnzB, int32_t *rowOffsetsB,
    int32_t *colIndsB, double *valuesB, size_t nnzR,
    int32_t *colOffsetsR, int32_t *rowIndsR, double *valuesR,
    double *UGamma, double *uStar)
{
    // splicer begin function.solveImmersedEqPrimes_d_i32
    solveImmersedEqPrimes_d_i32(resultPPrime, resultFPrime, nnzB,
        rowOffsetsB, colIndsB, valuesB, nnzR, colOffsetsR, rowIndsR,
        valuesR, UGamma, uStar);
    // splicer end function.solveImmersedEqPrimes_d_i32
}

void FOR_solveImmersedEqPrimes_s_i32(float *resultPPrime,
    float *resultFPrime, size_t nnzB, int32_t *rowOffsetsB,
    int32_t *colIndsB, float *valuesB, size_t nnzR,
    int32_t *colOffsetsR, int32_t *rowIndsR, float *valuesR,
    float *UGamma, float *uStar)
{
    // splicer begin function.solveImmersedEqPrimes_s_i32
    solveImmersedEqPrimes_s_i32(resultPPrime, resultFPrime, nnzB,
        rowOffsetsB, colIndsB, valuesB, nnzR, colOffsetsR, rowIndsR,
        valuesR, UGamma, uStar);
    // splicer end function.solveImmersedEqPrimes_s_i32
}

void FOR_solveImmersedEqPrimes_d_i64(double *resultPPrime,
    double *resultFPrime, size_t nnzB, int64_t *rowOffsetsB,
    int64_t *colIndsB, double *valuesB, size_t nnzR,
    int64_t *colOffsetsR, int64_t *rowIndsR, double *valuesR,
    double *UGamma, double *uStar)
{
    // splicer begin function.solveImmersedEqPrimes_d_i64
    solveImmersedEqPrimes_d_i64(resultPPrime, resultFPrime, nnzB,
        rowOffsetsB, colIndsB, valuesB, nnzR, colOffsetsR, rowIndsR,
        valuesR, UGamma, uStar);
    // splicer end function.solveImmersedEqPrimes_d_i64
}

void FOR_solveImmersedEqPrimes_s_i64(float *resultPPrime,
    float *resultFPrime, size_t nnzB, int64_t *rowOffsetsB,
    int64_t *colIndsB, float *valuesB, size_t nnzR,
    int64_t *colOffsetsR, int64_t *rowIndsR, float *valuesR,
    float *UGamma, float *uStar)
{
    // splicer begin function.solveImmersedEqPrimes_s_i64
    solveImmersedEqPrimes_s_i64(resultPPrime, resultFPrime, nnzB,
        rowOffsetsB, colIndsB, valuesB, nnzR, colOffsetsR, rowIndsR,
        valuesR, UGamma, uStar);
    // splicer end function.solveImmersedEqPrimes_s_i64
}

}  // extern "C"
