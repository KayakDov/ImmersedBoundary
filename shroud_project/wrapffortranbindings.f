! wrapffortranbindings.f
! This file is generated by Shroud 0.14.0. Do not edit.
!>
!! \file wrapffortranbindings.f
!! \brief Shroud generated wrapper for FortranBindings library
!<
! splicer begin file_top
! splicer end file_top
module fortranbindings_mod
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    interface

        subroutine c_init_immersed_eq_0(height, width, depth, fSize, &
                nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
                maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_0")
            use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: height
            integer(C_SIZE_T), value, intent(IN) :: width
            integer(C_SIZE_T), value, intent(IN) :: depth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_FLOAT), intent(IN) :: p(*)
            real(C_FLOAT), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_0

        subroutine c_init_immersed_eq_1(height, width, depth, fSize, &
                nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
                maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_1")
            use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: height
            integer(C_SIZE_T), value, intent(IN) :: width
            integer(C_SIZE_T), value, intent(IN) :: depth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_FLOAT), intent(IN) :: p(*)
            real(C_FLOAT), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_1

        subroutine c_init_immersed_eq_2(height, width, depth, fSize, &
                nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
                maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_2")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: height
            integer(C_SIZE_T), value, intent(IN) :: width
            integer(C_SIZE_T), value, intent(IN) :: depth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_DOUBLE), intent(IN) :: p(*)
            real(C_DOUBLE), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_2

        subroutine c_init_immersed_eq_3(height, width, depth, fSize, &
                nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
                maxBCGIterations) &
                bind(C, name="FOR_initImmersedEq_3")
            use iso_c_binding, only : C_DOUBLE, C_SIZE_T
            implicit none
            integer(C_SIZE_T), value, intent(IN) :: height
            integer(C_SIZE_T), value, intent(IN) :: width
            integer(C_SIZE_T), value, intent(IN) :: depth
            integer(C_SIZE_T), value, intent(IN) :: fSize
            integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
            real(C_DOUBLE), intent(IN) :: p(*)
            real(C_DOUBLE), intent(IN) :: f(*)
            real(C_DOUBLE), value, intent(IN) :: deltaX
            real(C_DOUBLE), value, intent(IN) :: deltaY
            real(C_DOUBLE), value, intent(IN) :: deltaZ
            real(C_DOUBLE), value, intent(IN) :: tolerance
            integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        end subroutine c_init_immersed_eq_3

        subroutine c_solve_immersed_eq(===>result i_dummy_arg<===, nnzB, &
                ===>rowPointersB i_dummy_arg<===, &
                ===>colPointersB i_dummy_arg<===, &
                ===>valuesB i_dummy_arg<===) &
                bind(C, name="FOR_solveImmersedEq")
            use iso_c_binding, only : C_SIZE_T
            implicit none
            ===>result i_dummy_decl<===
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            ===>rowPointersB i_dummy_decl<===
            ===>colPointersB i_dummy_decl<===
            ===>valuesB i_dummy_decl<===
        end subroutine c_solve_immersed_eq

        subroutine solve_immersed_eq(===>result i_dummy_arg<===, nnzB, &
                ===>rowPointersB i_dummy_arg<===, &
                ===>colPointersB i_dummy_arg<===, &
                ===>valuesB i_dummy_arg<===) &
                bind(C, name="FOR_solveImmersedEq_bufferify")
            use iso_c_binding, only : C_SIZE_T
            implicit none
            ===>result i_dummy_decl<===
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            ===>rowPointersB i_dummy_decl<===
            ===>colPointersB i_dummy_decl<===
            ===>valuesB i_dummy_decl<===
        end subroutine solve_immersed_eq

        subroutine c_solve_immersed_eq_0(result, nnzB, rowPointersB, &
                colPointersB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_0")
            use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT32_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowPointersB(*)
            integer(C_INT32_T), intent(IN) :: colPointersB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_0

        subroutine c_solve_immersed_eq_1(result, nnzB, rowPointersB, &
                colPointersB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_1")
            use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT64_T, C_SIZE_T
            implicit none
            real(C_FLOAT), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowPointersB(*)
            integer(C_INT64_T), intent(IN) :: colPointersB(*)
            real(C_FLOAT), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_1

        subroutine c_solve_immersed_eq_2(result, nnzB, rowPointersB, &
                colPointersB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_2")
            use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT32_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT32_T), intent(IN) :: rowPointersB(*)
            integer(C_INT32_T), intent(IN) :: colPointersB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_2

        subroutine c_solve_immersed_eq_3(result, nnzB, rowPointersB, &
                colPointersB, valuesB, multiStream) &
                bind(C, name="FOR_solveImmersedEq_3")
            use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT64_T, C_SIZE_T
            implicit none
            real(C_DOUBLE), intent(OUT) :: result(*)
            integer(C_SIZE_T), value, intent(IN) :: nnzB
            integer(C_INT64_T), intent(IN) :: rowPointersB(*)
            integer(C_INT64_T), intent(IN) :: colPointersB(*)
            real(C_DOUBLE), intent(IN) :: valuesB(*)
            logical(C_BOOL), value, intent(IN) :: multiStream
        end subroutine c_solve_immersed_eq_3
    end interface

    interface init_immersed_eq
        module procedure init_immersed_eq_0
        module procedure init_immersed_eq_1
        module procedure init_immersed_eq_2
        module procedure init_immersed_eq_3
    end interface init_immersed_eq

    interface solve_immersed_eq
        module procedure solve_immersed_eq
        module procedure solve_immersed_eq_0
        module procedure solve_immersed_eq_1
        module procedure solve_immersed_eq_2
        module procedure solve_immersed_eq_3
    end interface solve_immersed_eq

    ! splicer begin additional_declarations
    ! splicer end additional_declarations

contains

    subroutine init_immersed_eq_0(height, width, depth, nnzMaxB, p, f, &
            deltaX, deltaY, deltaZ, tolerance, maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: height
        integer(C_SIZE_T), value, intent(IN) :: width
        integer(C_SIZE_T), value, intent(IN) :: depth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_FLOAT), intent(IN) :: p(:)
        real(C_FLOAT), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_0
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_0(height, width, depth, SH_fSize, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_0
    end subroutine init_immersed_eq_0

    subroutine init_immersed_eq_1(height, width, depth, nnzMaxB, p, f, &
            deltaX, deltaY, deltaZ, tolerance, maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_FLOAT, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: height
        integer(C_SIZE_T), value, intent(IN) :: width
        integer(C_SIZE_T), value, intent(IN) :: depth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_FLOAT), intent(IN) :: p(:)
        real(C_FLOAT), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_1
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_1(height, width, depth, SH_fSize, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_1
    end subroutine init_immersed_eq_1

    subroutine init_immersed_eq_2(height, width, depth, nnzMaxB, p, f, &
            deltaX, deltaY, deltaZ, tolerance, maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: height
        integer(C_SIZE_T), value, intent(IN) :: width
        integer(C_SIZE_T), value, intent(IN) :: depth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_DOUBLE), intent(IN) :: p(:)
        real(C_DOUBLE), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_2
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_2(height, width, depth, SH_fSize, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_2
    end subroutine init_immersed_eq_2

    subroutine init_immersed_eq_3(height, width, depth, nnzMaxB, p, f, &
            deltaX, deltaY, deltaZ, tolerance, maxBCGIterations)
        use iso_c_binding, only : C_DOUBLE, C_SIZE_T
        integer(C_SIZE_T), value, intent(IN) :: height
        integer(C_SIZE_T), value, intent(IN) :: width
        integer(C_SIZE_T), value, intent(IN) :: depth
        integer(C_SIZE_T) :: SH_fSize
        integer(C_SIZE_T), value, intent(IN) :: nnzMaxB
        real(C_DOUBLE), intent(IN) :: p(:)
        real(C_DOUBLE), intent(IN) :: f(:)
        real(C_DOUBLE), value, intent(IN) :: deltaX
        real(C_DOUBLE), value, intent(IN) :: deltaY
        real(C_DOUBLE), value, intent(IN) :: deltaZ
        real(C_DOUBLE), value, intent(IN) :: tolerance
        integer(C_SIZE_T), value, intent(IN) :: maxBCGIterations
        ! splicer begin function.init_immersed_eq_3
        SH_fSize = size(f,kind=C_SIZE_T)
        call c_init_immersed_eq_3(height, width, depth, SH_fSize, &
            nnzMaxB, p, f, deltaX, deltaY, deltaZ, tolerance, &
            maxBCGIterations)
        ! splicer end function.init_immersed_eq_3
    end subroutine init_immersed_eq_3

    subroutine solve_immersed_eq_0(result, nnzB, rowPointersB, &
            colPointersB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT32_T, C_SIZE_T
        real(C_FLOAT), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT32_T), intent(IN) :: rowPointersB(:)
        integer(C_INT32_T), intent(IN) :: colPointersB(:)
        real(C_FLOAT), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_0
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_0(result, nnzB, rowPointersB, &
            colPointersB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_0
    end subroutine solve_immersed_eq_0

    subroutine solve_immersed_eq_1(result, nnzB, rowPointersB, &
            colPointersB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_FLOAT, C_INT64_T, C_SIZE_T
        real(C_FLOAT), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT64_T), intent(IN) :: rowPointersB(:)
        integer(C_INT64_T), intent(IN) :: colPointersB(:)
        real(C_FLOAT), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_1
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_1(result, nnzB, rowPointersB, &
            colPointersB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_1
    end subroutine solve_immersed_eq_1

    subroutine solve_immersed_eq_2(result, nnzB, rowPointersB, &
            colPointersB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT32_T, C_SIZE_T
        real(C_DOUBLE), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT32_T), intent(IN) :: rowPointersB(:)
        integer(C_INT32_T), intent(IN) :: colPointersB(:)
        real(C_DOUBLE), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_2
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_2(result, nnzB, rowPointersB, &
            colPointersB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_2
    end subroutine solve_immersed_eq_2

    subroutine solve_immersed_eq_3(result, nnzB, rowPointersB, &
            colPointersB, valuesB, multiStream)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT64_T, C_SIZE_T
        real(C_DOUBLE), intent(OUT) :: result(:)
        integer(C_SIZE_T), value, intent(IN) :: nnzB
        integer(C_INT64_T), intent(IN) :: rowPointersB(:)
        integer(C_INT64_T), intent(IN) :: colPointersB(:)
        real(C_DOUBLE), intent(IN) :: valuesB(:)
        logical, value, intent(IN) :: multiStream
        ! splicer begin function.solve_immersed_eq_3
        logical(C_BOOL) :: SHT_multiStream_cxx
        SHT_multiStream_cxx = multiStream  ! coerce to C_BOOL
        call c_solve_immersed_eq_3(result, nnzB, rowPointersB, &
            colPointersB, valuesB, SHT_multiStream_cxx)
        ! splicer end function.solve_immersed_eq_3
    end subroutine solve_immersed_eq_3

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module fortranbindings_mod
